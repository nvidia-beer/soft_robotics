#!/usr/bin/env python3
"""
Figure 2: Analysis of Classic PID Control

Compares P, PI, and PD control using classic (non-neural) PID implementation.
Demonstrates the response characteristics of each control variant.

The simulation initializes with volume ratio = 1.0 (rest state)
and inflates to target volume ratio = 2.0 (inflated state).

Output:
    figures/figure_classic.png
    figures/figure_classic.npz (raw data)

Usage:
    python figure_classic.py                    # Run with default parameters
    python figure_classic.py --total-time 15    # Custom simulation time
    python figure_classic.py --no-sim           # Plot from saved data only
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'warp'))
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import argparse
import numpy as np
from datetime import datetime

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

import warp as wp

from models import BalloonModel
from solvers import SolverImplicitFEM
from controllers.pid import PID


# ============================================================================
# Configuration
# ============================================================================
#
# PID gains loaded from pid_gains.txt (generated by ./run_tuning.sh)
# Same gains used for all controllers, just enable/disable terms to compare.
#

def load_pid_gains():
    """Load PID gains from config file, or use defaults."""
    config_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'pid_gains.txt')
    
    # Default values
    gains = {'KP': 27.0, 'KI': 103.8, 'KD': 1.76}
    
    if os.path.exists(config_file):
        with open(config_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#') or '=' not in line:
                    continue
                key, value = line.split('=', 1)
                key = key.strip()
                if key in gains:
                    gains[key] = float(value.strip())
        print(f"  Loaded PID gains from: {config_file}")
    else:
        print(f"  Using default PID gains (run ./run_tuning.sh to tune)")
    
    return gains['KP'], gains['KI'], gains['KD']

KP, KI, KD = load_pid_gains()

# Controller configurations: SAME gains, different terms enabled
CONTROLLER_CONFIGS = [
    ('P',   KP, 0.0, 0.0),   # P only: steady-state error expected
    ('PI',  KP, KI,  0.0),   # PI: integral eliminates offset
    ('PD',  KP, 0.0, KD),    # PD: derivative adds damping, still has offset
    ('PID', KP, KI,  KD),    # PID: best performance
]

# Figure output directory
FIGURES_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'figures')


def run_simulation(
    controller_name: str,
    Kp: float,
    Ki: float,
    Kd: float,
    total_time: float = 5.0,  # 500 steps
    dt: float = 0.01,
    initial_volume_ratio: float = 2.0,
    target_volume_ratio: float = 1.0,
    device: str = 'cuda',
    seed: int = 42,
):
    """
    Run a single simulation with specified controller configuration.
    
    Args:
        controller_name: Name for logging
        Kp, Ki, Kd: PID gains
        total_time: Simulation duration (seconds)
        dt: Physics time step
        initial_volume_ratio: Starting volume (relative to rest)
        target_volume_ratio: Target volume (relative to rest)
        device: 'cuda' or 'cpu'
        seed: Random seed
    
    Returns:
        dict with time series data
    """
    np.random.seed(seed)
    
    # Initialize Warp
    wp.init()
    
    print(f"\n{'='*60}")
    print(f"Running: {controller_name} Controller (Kp={Kp}, Ki={Ki}, Kd={Kd})")
    print(f"{'='*60}")
    
    # Create model
    model = BalloonModel(
        radius=0.5,
        num_boundary=16,
        num_rings=2,
        max_volume_ratio=max(initial_volume_ratio, target_volume_ratio) + 0.5,
        device=device,
        boxsize=3.0,
        spring_stiffness=1000.0,
        spring_damping=5.0,
        fem_E=2000.0,
        fem_nu=0.45,
        fem_damping=10.0,
    )
    
    # Create solver
    solver = SolverImplicitFEM(
        model,
        dt=dt,
        mass=1.0,
        preconditioner_type="diag",
        solver_type="bicgstab",
        max_iterations=50,
        tolerance=1e-4,
        rebuild_matrix_every=1,
    )
    
    # Create PID controller
    pid = PID(
        dt=dt,
        Kp=Kp,
        Ki=Ki,
        Kd=Kd,
        u_max=10.0,
        integral_limit=5.0,
        deadband=0.0001,
        derivative_filter=0.5,  # Moderate filter (0.5 = equal weight raw/filtered)
    )
    
    # Create states
    state = model.state()
    state_next = model.state()
    
    # Pre-inflate to initial volume
    print(f"  Pre-inflating to volume ratio = {initial_volume_ratio}...")
    for _ in range(100):
        current_vol = model.compute_current_volume(state)
        target_vol = model.initial_volume * initial_volume_ratio
        if abs(current_vol - target_vol) < 0.01:
            break
        
        # Simple proportional inflation
        error = target_vol - current_vol
        pressure = np.clip(error * 5.0, -10, 10)
        model.apply_inflation(state, pressure, initial_volume_ratio)
        solver.step(state, state_next, dt, external_forces=None)
        state, state_next = state_next, state
    
    actual_initial_ratio = model.compute_current_volume(state) / model.initial_volume
    print(f"  Initial volume ratio achieved: {actual_initial_ratio:.3f}")
    
    # Reset PID after pre-inflation
    pid.reset()
    
    # =========================================================================
    # Run Control Simulation
    # =========================================================================
    
    n_steps = int(total_time / dt)
    
    # Data storage
    times = []
    volumes = []
    errors = []
    pressures = []
    
    print(f"  Running {n_steps} steps (target ratio = {target_volume_ratio})...")
    
    for step in range(n_steps):
        # Current state
        current_volume = model.compute_current_volume(state)
        target_volume = model.initial_volume * target_volume_ratio
        
        # Compute error (for control: target - current)
        error = target_volume - current_volume
        
        # Get pressure from PID controller
        pressure = pid.compute(target_volume, current_volume)
        
        # Apply inflation control - use 1.0 as baseline so PID controls everything
        # pressure from PID determines inflation (not target_volume_ratio)
        model.apply_inflation(state, pressure, 1.0)
        
        # Physics step
        solver.step(state, state_next, dt, external_forces=None)
        state, state_next = state_next, state
        
        # Store data (normalized)
        sim_time = step * dt
        times.append(sim_time)
        volumes.append(current_volume / model.initial_volume)  # Volume ratio
        errors.append(error / model.initial_volume)  # Normalized error
        pressures.append(pressure)
        
        # Progress
        if step % 200 == 0:
            vol_ratio = current_volume / model.initial_volume
            print(f"    Step {step:4d}: vol={vol_ratio:.3f} err={error:.4f} p={pressure:.2f}")
    
    # Final state
    final_vol = model.compute_current_volume(state) / model.initial_volume
    print(f"  Final volume ratio: {final_vol:.3f} (target: {target_volume_ratio:.3f})")
    
    return {
        'name': controller_name,
        'Kp': Kp,
        'Ki': Ki,
        'Kd': Kd,
        'times': np.array(times),
        'volumes': np.array(volumes),
        'errors': np.array(errors),
        'pressures': np.array(pressures),
        'initial_ratio': initial_volume_ratio,
        'target_ratio': target_volume_ratio,
    }


def run_all_simulations(args):
    """Run simulations for all controller configurations."""
    
    results = {}
    
    for name, Kp, Ki, Kd in CONTROLLER_CONFIGS:
        data = run_simulation(
            controller_name=name,
            Kp=Kp,
            Ki=Ki,
            Kd=Kd,
            total_time=args.total_time,
            dt=args.dt,
            initial_volume_ratio=args.initial_volume,
            target_volume_ratio=args.target_volume,
            device=args.device,
            seed=args.seed,
        )
        results[name] = data
    
    # Save data
    os.makedirs(FIGURES_DIR, exist_ok=True)
    data_file = os.path.join(FIGURES_DIR, 'figure_classic.npz')
    
    np.savez(
        data_file,
        **{f"{k}_times": v['times'] for k, v in results.items()},
        **{f"{k}_volumes": v['volumes'] for k, v in results.items()},
        **{f"{k}_errors": v['errors'] for k, v in results.items()},
        **{f"{k}_pressures": v['pressures'] for k, v in results.items()},
        controller_names=[c[0] for c in CONTROLLER_CONFIGS],
        controller_params=[(c[1], c[2], c[3]) for c in CONTROLLER_CONFIGS],
        initial_volume=args.initial_volume,
        target_volume=args.target_volume,
    )
    print(f"\nData saved: {data_file}")
    
    return results


def create_figure(results, args):
    """
    Create 4-panel comparison figure (P, PI, PD, PID).
    
    Layout: 1 row x 4 columns
    Each subplot shows Volume, Error, and Pressure with different colors.
    Y-axis range: [0, 3] for all subplots.
    """
    
    # Figure style settings
    plt.rcParams.update({
        'font.size': 10,
        'axes.labelsize': 11,
        'axes.titlesize': 12,
        'legend.fontsize': 9,
        'figure.facecolor': 'white',
        'axes.facecolor': 'white',
        'axes.grid': True,
    })
    
    fig, axes = plt.subplots(1, 4, figsize=(16, 5), sharey=True)
    fig.subplots_adjust(left=0.06, right=0.98, top=0.85, bottom=0.12, 
                        wspace=0.08)
    
    # Plot each controller in its own subplot
    for col_idx, (name, Kp, Ki, Kd) in enumerate(CONTROLLER_CONFIGS):
        ax = axes[col_idx]
        data = results[name]
        times = data['times']
        volumes = data['volumes']
        errors = data['errors']
        pressures = data['pressures']
        
        # Plot YELLOW/ORANGE PRESSURE FIRST (so it's behind)
        ax.plot(times, pressures, color='#FFAA00', linewidth=2, label='Pressure', zorder=1)
        
        # Plot RED ERROR
        ax.plot(times, errors, color='#CC0000', linewidth=1.5, label='Error', zorder=2)
        
        # Plot BLACK VOLUME (PID response)
        ax.plot(times, volumes, color='black', linewidth=2, label=name, zorder=3)
        
        # Target line - RED DASHED at y=2.0 (actual target)
        ax.axhline(y=2.0, color='#CC0000', linestyle='--', linewidth=1.5, label='Target', zorder=4)
        
        # Calculate final error
        final_vol = volumes[-1]
        final_error = abs(2.0 - final_vol)
        
        ax.set_title(f'{name} Control\n(error: {final_error:.3f})', fontsize=10)
        ax.set_xlabel('Time (s)')
        ax.set_ylim(0, 3)
        ax.set_ylabel('Value' if col_idx == 0 else '')
        ax.grid(True, alpha=0.3)
        
        # Legend in lower right
        ax.legend(loc='lower right', fontsize=8)
    
    # Global title with parameters
    params_str = f"Kp={KP}, Ki={KI}, Kd={KD}"
    
    fig.suptitle(
        f"Analysis of Classic PID Control\n"
        f"{params_str}",
        fontsize=12, fontweight='bold', y=0.98
    )
    
    # Save figure
    os.makedirs(FIGURES_DIR, exist_ok=True)
    output_file = os.path.join(FIGURES_DIR, 'figure_classic.png')
    plt.savefig(output_file, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"\nFigure saved: {output_file}")
    
    # Also save as PDF for publication
    pdf_file = os.path.join(FIGURES_DIR, 'figure_classic.pdf')
    plt.savefig(pdf_file, bbox_inches='tight', facecolor='white')
    print(f"PDF saved: {pdf_file}")
    
    plt.close()
    
    return output_file


def plot_from_data(data_file, args):
    """Load saved data and create figure."""
    
    print(f"Loading data from: {data_file}")
    data = np.load(data_file, allow_pickle=True)
    
    # Reconstruct results dict
    controller_names = data['controller_names']
    results = {}
    
    for name in controller_names:
        results[name] = {
            'name': name,
            'times': data[f'{name}_times'],
            'volumes': data[f'{name}_volumes'],
            'errors': data[f'{name}_errors'],
            'pressures': data[f'{name}_pressures'],
        }
    
    return create_figure(results, args)


def main():
    parser = argparse.ArgumentParser(
        description='Generate Figure 2: Classic PID Control Analysis',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python figure_classic.py                      # Run full simulation and plot
  python figure_classic.py --total-time 15      # Longer simulation
  python figure_classic.py --no-sim             # Plot from saved data
  python figure_classic.py --device cpu         # Use CPU instead of GPU
        """
    )
    
    # Simulation parameters
    parser.add_argument('--total-time', '-t', type=float, default=5.0,
                       help='Total simulation time in seconds (default: 5)')
    parser.add_argument('--dt', type=float, default=0.01,
                       help='Physics time step (default: 0.01)')
    
    # Initial conditions
    parser.add_argument('--initial-volume', type=float, default=1.0,
                       help='Initial volume ratio (default: 1.0)')
    parser.add_argument('--target-volume', type=float, default=2.0,
                       help='Target volume ratio (default: 2.0)')
    
    # Hardware
    parser.add_argument('--device', type=str, default='cuda',
                       choices=['cuda', 'cpu'],
                       help='Compute device (default: cuda)')
    parser.add_argument('--seed', type=int, default=42,
                       help='Random seed (default: 42)')
    
    # Run options
    parser.add_argument('--no-sim', action='store_true',
                       help='Skip simulation, only plot from saved data')
    parser.add_argument('--data-file', type=str, default=None,
                       help='Data file to plot (default: figure_classic.npz)')
    
    args = parser.parse_args()
    
    print("\n" + "=" * 70)
    print("  FIGURE 2: Analysis of Classic PID Control")
    print("=" * 70)
    print(f"\nPID gains: Kp={KP}, Ki={KI}, Kd={KD}")
    print(f"\nController configurations:")
    for name, Kp, Ki, Kd in CONTROLLER_CONFIGS:
        print(f"  {name:3s}: Kp={Kp}, Ki={Ki}, Kd={Kd}")
    
    if args.no_sim:
        # Plot from saved data
        data_file = args.data_file or os.path.join(FIGURES_DIR, 'figure_classic.npz')
        if not os.path.exists(data_file):
            print(f"\nError: Data file not found: {data_file}")
            print("Run without --no-sim first to generate data.")
            return 1
        
        plot_from_data(data_file, args)
    else:
        # Run simulations and create figure
        print(f"\nSimulation settings:")
        print(f"  Initial volume ratio: {args.initial_volume}")
        print(f"  Target volume ratio: {args.target_volume}")
        print(f"  Total time: {args.total_time}s")
        print(f"  Device: {args.device}")
        
        results = run_all_simulations(args)
        create_figure(results, args)
    
    print("\n" + "=" * 70)
    print("  Figure generation complete!")
    print("=" * 70)
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
